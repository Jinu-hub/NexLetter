// apps/integrations/github/githubFetch.ts
import "dotenv/config";
import { Octokit } from "@octokit/rest";
import dayjs from "dayjs";
import fs from "node:fs";
import path from "node:path";

export type Repo = { owner: string; name: string };

type UserInfo = {
  login: string;
  name?: string;
  email?: string;
  avatar_url?: string;
};

type CommitInfo = { 
  sha: string; 
  message: string; 
  author: string; 
  html_url: string; 
  date: string;
  userInfo?: UserInfo;
};

type PRInfo = { 
  number: number; 
  title: string; 
  user: string; 
  html_url: string; 
  merged_at: string;
  userInfo?: UserInfo;
};

type IssueInfo = { 
  number: number; 
  title: string; 
  user: string; 
  html_url: string; 
  state: "open"|"closed"; 
  created_at: string; 
  closed_at?: string|null;
  userInfo?: UserInfo;
};

type FetchedRepoData = {
  repo: Repo;
  commits: CommitInfo[];
  mergedPRs: PRInfo[];
  openedIssues: IssueInfo[];
  closedIssues: IssueInfo[];
};

const TARGET_REPOS = (process.env.GITHUB_REPOS || "").split(",").filter(Boolean).map(repo => {
  const [owner, name] = repo.split("/");
  return { owner, name };
});
// 예: .env에 GITHUB_REPOS=owner1/repo1,owner2/repo2 처럼 넣어두기
const DAYS = Number(process.env.FETCH_DAYS || 7);
const token = process.env.GITHUB_TOKEN!;

if (!token) {
  console.error("Missing GITHUB_TOKEN");
  process.exit(1);
}

// 사용자 정보 캐시
const userCache = new Map<string, UserInfo>();

async function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

async function fetchUserInfo(octokit: Octokit, username: string): Promise<UserInfo | null> {
  // 캐시에서 확인
  if (userCache.has(username)) {
    return userCache.get(username)!;
  }

  try {
    const res = await octokit.users.getByUsername({ username });
    if (res.data) {
      const userInfo: UserInfo = {
        login: res.data.login,
        name: res.data.name || undefined,
        email: res.data.email || undefined,
        avatar_url: res.data.avatar_url || undefined,
      };
      
      // 캐시에 저장
      userCache.set(username, userInfo);
      return userInfo;
    }
  } catch (error) {
    console.warn(`Failed to fetch user info for ${username}:`, error);
  }
  
  return null;
}

async function fetchRepoData(octokit: Octokit, repo: Repo, oldestTs: string): Promise<FetchedRepoData> {
  const now = dayjs();
  const since = dayjs.unix(Number(oldestTs)).toISOString();
  const until = now.toISOString();
  
  // 커밋 수집
  const commitsApi = await octokit.paginate(octokit.repos.listCommits, {
    owner: repo.owner, 
    repo: repo.name, 
    since, 
    until, 
    per_page: 100
  });
  
  const commits: CommitInfo[] = [];
  for (const c of commitsApi) {
    const authorLogin = c.author?.login || c.commit?.author?.name || "unknown";
    const userInfo = authorLogin !== "unknown" ? await fetchUserInfo(octokit, authorLogin) : null;
    
    commits.push({
      sha: c.sha!,
      message: (c.commit?.message || "").split("\n")[0],
      author: authorLogin,
      html_url: c.html_url!,
      date: c.commit?.author?.date || "",
      userInfo: userInfo || undefined,
    });
    
    // Rate limit 방지
    await sleep(100);
  }

  // 병합된 PR 수집
  const sDate = since.split("T")[0];
  const uDate = until.split("T")[0];
  const merged = await octokit.paginate(octokit.search.issuesAndPullRequests, {
    q: `repo:${repo.owner}/${repo.name} is:pr is:merged merged:${sDate}..${uDate}`,
    per_page: 100
  });
  
  const mergedPRs: PRInfo[] = [];
  for (const pr of merged) {
    const userLogin = pr.user?.login || "unknown";
    const userInfo = userLogin !== "unknown" ? await fetchUserInfo(octokit, userLogin) : null;
    
    mergedPRs.push({
      number: pr.number!,
      title: pr.title!,
      user: userLogin,
      html_url: pr.html_url!,
      merged_at: pr.closed_at || "",
      userInfo: userInfo || undefined,
    });
    
    await sleep(100);
  }

  // 새로 생성된 이슈
  const opened = await octokit.paginate(octokit.search.issuesAndPullRequests, {
    q: `repo:${repo.owner}/${repo.name} is:issue created:${sDate}..${uDate}`,
    per_page: 100
  });
  
  const openedIssues: IssueInfo[] = [];
  for (const issue of opened) {
    const userLogin = issue.user?.login || "unknown";
    const userInfo = userLogin !== "unknown" ? await fetchUserInfo(octokit, userLogin) : null;
    
    openedIssues.push({
      number: issue.number!,
      title: issue.title!,
      user: userLogin,
      html_url: issue.html_url!,
      state: "open",
      created_at: issue.created_at || "",
      closed_at: issue.closed_at || null,
      userInfo: userInfo || undefined,
    });
    
    await sleep(100);
  }

  // 종료된 이슈
  const closed = await octokit.paginate(octokit.search.issuesAndPullRequests, {
    q: `repo:${repo.owner}/${repo.name} is:issue is:closed closed:${sDate}..${uDate}`,
    per_page: 100
  });
  
  const closedIssues: IssueInfo[] = [];
  for (const issue of closed) {
    const userLogin = issue.user?.login || "unknown";
    const userInfo = userLogin !== "unknown" ? await fetchUserInfo(octokit, userLogin) : null;
    
    closedIssues.push({
      number: issue.number!,
      title: issue.title!,
      user: userLogin,
      html_url: issue.html_url!,
      state: "closed",
      created_at: issue.created_at || "",
      closed_at: issue.closed_at || null,
      userInfo: userInfo || undefined,
    });
    
    await sleep(100);
  }

  return {
    repo,
    commits,
    mergedPRs,
    openedIssues,
    closedIssues,
  };
}

async function main() {
  const octokit = new Octokit({ auth: token });
  const now = dayjs();
  const oldestTs = now.subtract(DAYS, "day").unix().toString();

  const reposToFetch = TARGET_REPOS.length > 0 ? TARGET_REPOS : [
    { owner: "facebook", name: "react" } // 기본 샘플
  ];

  const result: Record<string, FetchedRepoData> = {};
  
  for (const repo of reposToFetch) {
    console.log("⏬ fetch repo:", `${repo.owner}/${repo.name}`);
    const repoKey = `${repo.owner}/${repo.name}`;
    result[repoKey] = await fetchRepoData(octokit, repo, oldestTs);
  }

  // 파일 저장(JSON) — DB 연동 전 임시 아웃풋
  const outDir = process.env.OUT_DIR || "output";
  fs.mkdirSync(outDir, { recursive: true });
  
  const outputFile = path.join(outDir, "github_raw.json");
  fs.writeFileSync(outputFile, JSON.stringify(result, null, 2), "utf-8");
  console.log(`✔ saved: ${outputFile}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
